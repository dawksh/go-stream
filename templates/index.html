<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Torrent Stream</title>
<link rel="stylesheet" href="https://cdn.plyr.io/3.7.8/plyr.css" />
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    background: #0f0f0f; color: #e0e0e0;
    display: flex; justify-content: center;
    min-height: 100vh; padding: 2rem 1rem;
  }
  .container { max-width: 960px; width: 100%; }
  .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
  h1 { font-size: 1.5rem; color: #fff; }
  .cleanup-btn { padding: 0.4rem 0.8rem; font-size: 0.8rem; background: #dc2626; }
  .cleanup-btn:hover { background: #b91c1c; }

  .input-group { display: flex; gap: 0.5rem; margin-bottom: 1.5rem; }
  input[type="text"] {
    flex: 1; padding: 0.6rem 0.8rem; border-radius: 6px;
    border: 1px solid #333; background: #1a1a1a; color: #fff;
    font-size: 0.9rem; outline: none;
  }
  input[type="text"]:focus { border-color: #555; }
  button {
    padding: 0.6rem 1.2rem; border-radius: 6px; border: none;
    background: #2563eb; color: #fff; font-size: 0.9rem;
    cursor: pointer; white-space: nowrap;
  }
  button:hover { background: #1d4ed8; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }

  .status { padding: 0.8rem; margin-bottom: 1rem; border-radius: 6px; font-size: 0.85rem; display: none; }
  .status.error { display: block; background: #3b1111; color: #f87171; border: 1px solid #7f1d1d; }
  .status.loading { display: block; background: #1a1a2e; color: #93c5fd; border: 1px solid #1e3a5f; }

  .torrent-name { font-size: 1.1rem; font-weight: 600; margin-bottom: 0.75rem; color: #fff; display: none; }

  table { width: 100%; border-collapse: collapse; margin-bottom: 1.5rem; display: none; }
  th { text-align: left; padding: 0.5rem; border-bottom: 2px solid #333; font-size: 0.8rem; color: #888; text-transform: uppercase; }
  td { padding: 0.5rem; border-bottom: 1px solid #1f1f1f; font-size: 0.85rem; word-break: break-all; }
  tr:hover { background: #1a1a1a; }
  .size { white-space: nowrap; color: #888; word-break: normal; }
  .play-btn { padding: 0.3rem 0.8rem; font-size: 0.8rem; background: #16a34a; }
  .play-btn:hover { background: #15803d; }

  .player-section { display: none; margin-bottom: 1.5rem; }
  .player-section .plyr { --plyr-color-main: #2563eb; border-radius: 8px; overflow: hidden; }

  .player-controls { display: flex; align-items: center; gap: 0.75rem; margin-top: 0.75rem; flex-wrap: wrap; }
  .player-controls label {
    display: inline-flex; align-items: center; gap: 0.4rem;
    padding: 0.4rem 0.8rem; border-radius: 6px;
    background: #1e1e1e; border: 1px solid #333; color: #ccc;
    cursor: pointer; font-size: 0.8rem; transition: border-color 0.15s;
  }
  .player-controls label:hover { border-color: #555; }
  .player-controls input[type="file"] { display: none; }
  .sub-list { font-size: 0.8rem; color: #888; }

  .sub-search { display: none; margin-top: 1rem; }
  .sub-search-bar { display: flex; gap: 0.5rem; margin-bottom: 0.75rem; }
  .sub-search-bar input { flex: 1; padding: 0.4rem 0.6rem; border-radius: 6px; border: 1px solid #333; background: #1a1a1a; color: #fff; font-size: 0.8rem; outline: none; }
  .sub-search-bar select { padding: 0.4rem; border-radius: 6px; border: 1px solid #333; background: #1a1a1a; color: #fff; font-size: 0.8rem; outline: none; }
  .sub-search-bar button { padding: 0.4rem 0.8rem; font-size: 0.8rem; }
  .sub-results { max-height: 240px; overflow-y: auto; border-radius: 6px; }
  .sub-results:empty { display: none; }
  .sub-result-item {
    display: flex; align-items: center; justify-content: space-between; gap: 0.5rem;
    padding: 0.5rem 0.6rem; border-bottom: 1px solid #1f1f1f; font-size: 0.8rem;
  }
  .sub-result-item:hover { background: #1a1a1a; }
  .sub-result-info { flex: 1; min-width: 0; }
  .sub-result-name { color: #e0e0e0; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .sub-result-meta { color: #666; font-size: 0.7rem; margin-top: 2px; }
  .sub-dl-btn { padding: 0.25rem 0.6rem; font-size: 0.75rem; background: #7c3aed; flex-shrink: 0; }
  .sub-dl-btn:hover { background: #6d28d9; }
  .sub-dl-btn:disabled { opacity: 0.5; }
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Torrent Stream</h1>
    <button class="cleanup-btn" onclick="cleanupAll()">Clean All Data</button>
  </div>

  <div class="input-group">
    <input type="text" id="magnetInput" placeholder="Paste magnet link here..." />
    <button id="addBtn" onclick="addMagnet()">Add</button>
  </div>

  <div id="status" class="status"></div>
  <div id="torrentName" class="torrent-name"></div>

  <table id="fileTable">
    <thead><tr><th>File</th><th>Size</th><th></th></tr></thead>
    <tbody id="fileBody"></tbody>
  </table>

  <div id="playerSection" class="player-section">
    <video id="videoPlayer" crossorigin="anonymous" playsinline></video>
    <div class="player-controls" id="playerControls" style="display:none;">
      <label>Upload Subtitle <input type="file" accept=".srt,.vtt,.ass,.sub" onchange="uploadSubtitle(this.files[0])" /></label>
      <button onclick="toggleSubSearch()" style="font-size:0.8rem; background:#7c3aed;">Search Subtitles</button>
      <span class="sub-list" id="subList"></span>
    </div>
    <div class="sub-search" id="subSearch">
      <div class="sub-search-bar">
        <input type="text" id="subQuery" placeholder="Search query (auto-filled from file name)" />
        <select id="subLang">
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
          <option value="de">German</option>
          <option value="pt-br">Portuguese (BR)</option>
          <option value="it">Italian</option>
          <option value="nl">Dutch</option>
          <option value="pl">Polish</option>
          <option value="ru">Russian</option>
          <option value="zh-cn">Chinese</option>
          <option value="ja">Japanese</option>
          <option value="ko">Korean</option>
          <option value="ar">Arabic</option>
          <option value="hi">Hindi</option>
        </select>
        <button id="subSearchBtn" onclick="searchSubtitles()">Search</button>
      </div>
      <div class="sub-results" id="subResults"></div>
    </div>
  </div>
</div>

<script src="https://cdn.plyr.io/3.7.8/plyr.polyfilled.js"></script>
<script>
let currentTorrentId = null;
let player = null;

function initPlayer() {
  if (player) return;
  player = new Plyr('#videoPlayer', {
    controls: ['play-large', 'play', 'progress', 'current-time', 'duration',
               'mute', 'volume', 'captions', 'settings', 'pip', 'fullscreen'],
    settings: ['captions', 'quality', 'speed'],
    captions: { active: true, update: true },
    keyboard: { focused: true, global: true },
    tooltips: { controls: true, seek: true },
    speed: { selected: 1, options: [0.5, 0.75, 1, 1.25, 1.5, 2] },
  });
}

function showStatus(msg, type) {
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = 'status ' + type;
}

function hideStatus() {
  document.getElementById('status').className = 'status';
}

function formatSize(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024, sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return (bytes / Math.pow(k, i)).toFixed(1) + ' ' + sizes[i];
}

async function addMagnet() {
  const input = document.getElementById('magnetInput');
  const magnet = input.value.trim();
  if (!magnet) return;

  const btn = document.getElementById('addBtn');
  btn.disabled = true;
  showStatus('Fetching torrent metadata... this may take a moment.', 'loading');

  try {
    const resp = await fetch('/api/magnet', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({magnet})
    });
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      return;
    }
    hideStatus();
    renderTorrent(json.data);
  } catch (e) {
    showStatus('Network error: ' + e.message, 'error');
  } finally {
    btn.disabled = false;
  }
}

function renderTorrent(data) {
  currentTorrentId = data.id;

  document.getElementById('torrentName').textContent = data.name;
  document.getElementById('torrentName').style.display = 'block';

  const tbody = document.getElementById('fileBody');
  tbody.innerHTML = '';
  data.files.forEach(f => {
    const tr = document.createElement('tr');
    const actionCell = f.isVideo
      ? `<button class="play-btn" onclick="selectFile(${f.index})">Play</button>`
      : '';
    tr.innerHTML = `<td>${escapeHtml(f.path)}</td><td class="size">${formatSize(f.length)}</td><td>${actionCell}</td>`;
    tbody.appendChild(tr);
  });
  document.getElementById('fileTable').style.display = 'table';
}

async function selectFile(fileIndex) {
  showStatus('Preparing stream...', 'loading');
  try {
    const resp = await fetch(`/api/select/${currentTorrentId}`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({fileIndex})
    });
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      return;
    }
    hideStatus();
    startPlayer(json.data);
  } catch (e) {
    showStatus('Network error: ' + e.message, 'error');
  }
}

function startPlayer(data) {
  const section = document.getElementById('playerSection');
  const video = document.getElementById('videoPlayer');

  // Remove old tracks
  video.querySelectorAll('track').forEach(t => t.remove());

  video.src = data.streamUrl;

  if (data.subtitles) {
    data.subtitles.forEach((s, i) => {
      addTrack(video, s.url, s.name, i === 0);
    });
  }

  section.style.display = 'block';
  document.getElementById('playerControls').style.display = 'flex';
  updateSubList(data.subtitles || []);

  initPlayer();
  // Plyr needs a nudge after source change
  player.media.load();
  player.play().catch(() => {});
}

function addTrack(video, url, label, isDefault) {
  const track = document.createElement('track');
  track.kind = 'captions';
  track.label = label;
  track.src = url;
  track.srclang = 'en';
  if (isDefault) track.default = true;
  video.appendChild(track);
}

function updateSubList(subs) {
  const el = document.getElementById('subList');
  if (subs.length === 0) {
    el.textContent = 'No subtitles loaded.';
  } else {
    el.textContent = 'Subs: ' + subs.map(s => s.name).join(', ');
  }
}

async function uploadSubtitle(file) {
  if (!file || !currentTorrentId) return;

  const form = new FormData();
  form.append('subtitle', file);

  try {
    const resp = await fetch(`/api/subtitle/${currentTorrentId}`, {
      method: 'POST',
      body: form
    });
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      return;
    }

    const video = document.getElementById('videoPlayer');
    addTrack(video, json.data.url, json.data.name, false);

    const subList = document.getElementById('subList');
    const current = subList.textContent;
    if (current.startsWith('No subtitles')) {
      subList.textContent = 'Subs: ' + json.data.name;
    } else {
      subList.textContent = current + ', ' + json.data.name;
    }
  } catch (e) {
    showStatus('Upload failed: ' + e.message, 'error');
  }
}

function toggleSubSearch() {
  const el = document.getElementById('subSearch');
  el.style.display = el.style.display === 'block' ? 'none' : 'block';
}

async function searchSubtitles() {
  if (!currentTorrentId) return;

  const query = document.getElementById('subQuery').value.trim();
  const lang = document.getElementById('subLang').value;
  const btn = document.getElementById('subSearchBtn');
  btn.disabled = true;
  btn.textContent = 'Searching...';

  try {
    const params = new URLSearchParams({lang});
    if (query) params.set('query', query);
    const resp = await fetch(`/api/subtitles/${currentTorrentId}?${params}`);
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      return;
    }
    renderSubResults(json.data || []);
  } catch (e) {
    showStatus('Search failed: ' + e.message, 'error');
  } finally {
    btn.disabled = false;
    btn.textContent = 'Search';
  }
}

function renderSubResults(results) {
  const el = document.getElementById('subResults');
  if (results.length === 0) {
    el.innerHTML = '<div style="padding:0.5rem;color:#666;font-size:0.8rem;">No subtitles found.</div>';
    return;
  }
  el.innerHTML = results.map(r => `
    <div class="sub-result-item">
      <div class="sub-result-info">
        <div class="sub-result-name" title="${escapeHtml(r.release || r.fileName)}">${escapeHtml(r.release || r.fileName)}</div>
        <div class="sub-result-meta">${escapeHtml(r.language)} &middot; ${r.downloads} downloads</div>
      </div>
      <button class="sub-dl-btn" onclick="downloadSubtitle(${r.fileId}, this)">Add</button>
    </div>
  `).join('');
}

async function downloadSubtitle(fileId, btn) {
  if (!currentTorrentId) return;
  btn.disabled = true;
  btn.textContent = 'Adding...';

  try {
    const resp = await fetch(`/api/subtitles/${currentTorrentId}/download`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({fileId})
    });
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      btn.disabled = false;
      btn.textContent = 'Add';
      return;
    }

    const video = document.getElementById('videoPlayer');
    addTrack(video, json.data.url, json.data.name, false);

    const subList = document.getElementById('subList');
    const current = subList.textContent;
    if (current.startsWith('No subtitles') || current === '') {
      subList.textContent = 'Subs: ' + json.data.name;
    } else {
      subList.textContent = current + ', ' + json.data.name;
    }

    btn.textContent = 'Added';
  } catch (e) {
    showStatus('Download failed: ' + e.message, 'error');
    btn.disabled = false;
    btn.textContent = 'Add';
  }
}

async function cleanupAll() {
  if (!confirm('Remove all torrents and downloaded data?')) return;
  try {
    const resp = await fetch('/api/cleanup', {method: 'POST'});
    const json = await resp.json();
    if (!json.ok) {
      showStatus(json.error, 'error');
      return;
    }
    // Reset UI
    document.getElementById('fileTable').style.display = 'none';
    document.getElementById('torrentName').style.display = 'none';
    document.getElementById('playerSection').style.display = 'none';
    document.getElementById('playerControls').style.display = 'none';
    document.getElementById('subSearch').style.display = 'none';
    currentTorrentId = null;
    showStatus('All data cleaned.', 'loading');
    setTimeout(hideStatus, 2000);
  } catch (e) {
    showStatus('Cleanup failed: ' + e.message, 'error');
  }
}

function escapeHtml(s) {
  const d = document.createElement('div');
  d.textContent = s;
  return d.innerHTML;
}

document.getElementById('magnetInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') addMagnet();
});
</script>
</body>
</html>
